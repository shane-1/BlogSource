(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{464:function(e,t,a){"use strict";a.r(t);var s=a(28),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"pwa介绍及快速上手搭建一个pwa应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pwa介绍及快速上手搭建一个pwa应用"}},[e._v("#")]),e._v(" PWA介绍及快速上手搭建一个PWA应用")]),e._v(" "),a("blockquote",[a("p",[e._v("作者 游魂 | 发布于 2018-04-27")])]),e._v(" "),a("h2",{attrs:{id:"pwa初次体验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pwa初次体验"}},[e._v("#")]),e._v(" PWA初次体验")]),e._v(" "),a("blockquote",[a("p",[e._v("前言：本示例不用安装任何东西")]),e._v(" "),a("p",[e._v("部分资源来自网络资源及PWA官网，不要把PWA想象的太复杂，跟着示例走一下，你行的。")])]),e._v(" "),a("h3",{attrs:{id:"pwa介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pwa介绍"}},[e._v("#")]),e._v(" PWA介绍")]),e._v(" "),a("p",[e._v("一个新的前端技术，PWA（ 全称：Progressive Web App ）也就是说这是个渐进式的网页应用程序。")]),e._v(" "),a("p",[e._v("官网："),a("a",{attrs:{href:"https://developers.google.com/web/progressive-web-apps/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developers.google.com..."),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("是 Google 在 2015 年提出，2016年6月才推广的项目。是结合了一系列现代Web技术的组合，在网页应用中实现和原生应用相近的用户体验。")]),e._v(" "),a("p",[e._v("官网上给出 PWA 的宣传是 ： "),a("strong",[e._v("Reliable")]),e._v(" （ 可靠的 ）、"),a("strong",[e._v("Fast")]),e._v("（ 快速的 ）、"),a("strong",[e._v("Engaging")]),e._v("（ 可参与的 ）")]),e._v(" "),a("p",[a("strong",[e._v("Reliable")]),e._v(" ：当用户从手机主屏幕启动时，不用考虑网络的状态是如何，都可以立刻加载出 PWA。")]),e._v(" "),a("p",[a("strong",[e._v("Fast")]),e._v("：这一点应该都很熟悉了吧，站在用户的角度来考虑，如果一个网页加载速度有点长的话，那么我们会放弃浏览该网站，所以 PWA 在这一点上做的很好，他的加载速度是很快的。")]),e._v(" "),a("p",[a("strong",[e._v("Engaging")]),e._v(" ： PWA 可以添加在用户的主屏幕上，不用从应用商店进行下载，他们通过网络应用程序 Manifest file 提供类似于 APP 的使用体验（ 在 Android 上可以设置全屏显示哦，由于 Safari 支持度的问题，所以在 IOS 上并不可以 ），并且还能进行 ”推送通知” 。")]),e._v(" "),a("h3",{attrs:{id:"pwa关键技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pwa关键技术"}},[e._v("#")]),e._v(" PWA关键技术")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Service Worker")]),e._v(" （可以理解为服务工厂）")]),e._v(" "),a("li",[a("strong",[e._v("Manifest")]),e._v(" （应用清单）")]),e._v(" "),a("li",[a("strong",[e._v("Push Notification")]),e._v("（推送通知）")])]),e._v(" "),a("h4",{attrs:{id:"service-worker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[e._v("#")]),e._v(" Service Worker")]),e._v(" "),a("p",[e._v("以下用SW来表示")]),e._v(" "),a("p",[e._v("SW 是什么呢？这个是离线缓存文件。我们 PWA 技术使用的就是它！SW 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门，因为使用了它，才会有的那个 Reliable 特性吧，SW 作用于 浏览器于服务器之间，相当于一个代理服务器。")]),e._v(" "),a("p",[a("strong",[e._v("浏览器支持")])]),e._v(" "),a("p",[e._v("顺便带一句：目前只能在 HTTPS 环境下才能使用SW，因为SW 的权利比较大，能够直接截取和返回用户的请求，所以要考虑一下安全性问题。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639478?w=2048&h=498",alt:"img"}})]),e._v(" "),a("p",[a("strong",[e._v("事件机制")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639479?w=598&h=164",alt:"img"}})]),e._v(" "),a("p",[a("strong",[e._v("功能")]),e._v("(还是比较逆天的)")]),e._v(" "),a("ul",[a("li",[e._v("后台数据的同步")]),e._v(" "),a("li",[e._v("从其他域获取资源请求")]),e._v(" "),a("li",[e._v("接受计算密集型数据的更新，多页面共享该数据")]),e._v(" "),a("li",[e._v("客户端编译与依赖管理")]),e._v(" "),a("li",[e._v("后端服务的hook机制")]),e._v(" "),a("li",[e._v("根据URL模式，自定义模板")]),e._v(" "),a("li",[e._v("性能优化")]),e._v(" "),a("li",[e._v("消息推送")]),e._v(" "),a("li",[e._v("定时默认更新")]),e._v(" "),a("li",[e._v("地理围栏")])]),e._v(" "),a("p",[a("strong",[e._v("生命周期")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639480?w=772&h=232",alt:"img"}})]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Parsed （ 解析成功 ）： 首次注册 SW 时，浏览器解决脚本并获得入口点，如果解析成功，就可以访问到 SW 注册对象，在这一点中我们需要在 HTML 页面中添加一个判断，判断该浏览器是否支持 SW 。")])]),e._v(" "),a("li",[a("p",[e._v("Installing （ 正在安装 ）：SW 脚本解析完成之后，浏览器会尝试进行安装，installing 中 install 事件被执行，如果其中有 event.waitUntil ( ) 方法，则 installing 事件会一直等到该方法中的 Promise 完成之后才会成功，如果 Promise 被拒绝，则安装失败，SW会进入 Redundant（ 废弃 ）状态。")])]),e._v(" "),a("li",[a("p",[e._v("Installed / Waiting （安装成功/等待中）：如果安装成功，SW 将会进入这个状态。")])]),e._v(" "),a("li",[a("p",[e._v("Activating （ 正在激活 ）：处于 waiting 状态的 SW 发生以下情况，将会进入 activating 状态中：")]),e._v(" "),a("p",[e._v("当前已无激活状态的 worker 、 SW脚本中的 self.skipWaiting（）方法被调用 （ ps： self 是 SW 中作用于全局的对象，这个方法根据英文翻译过来也能明白什么意思啦，跳过等待状态 ）、用户已关闭 SW 作用域下的所有页面，从而释放了当前处于激活状态的 worker、超出指定时间，从而释放当前处于激活状态的 worker")])]),e._v(" "),a("li",[a("p",[e._v("Activated （ 激活成功 ）：该状态，其成功接收了 document 全面控制的激活态 worker 。")])]),e._v(" "),a("li",[a("p",[e._v("Redundant （ 废弃 ）：这个状态的出现时有原因的，如果 installing 事件失败或者 activating 事件失败或者新的 SW 替换其成为激活态 worker 。installing 事件失败和 activating 事件失败的信息我们可以在 Chrome 浏览器的 DevTools 中查看")])])]),e._v(" "),a("p",[e._v("一个很不错的全面介绍sw的教程：[https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6](https://www.villainhr.com/page/2017/01/08/Service Worker 全面进阶)")]),e._v(" "),a("h4",{attrs:{id:"manifest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#manifest"}},[e._v("#")]),e._v(" Manifest")]),e._v(" "),a("p",[e._v("Web App Manifest 是一个 W3C 规范，它定义了一个基于 JSON 的 List 。Manifest 在 PWA 中的作用有：")]),e._v(" "),a("p",[e._v("能够将你浏览的网页添加到你的手机屏幕上")]),e._v(" "),a("p",[e._v("在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）")]),e._v(" "),a("p",[e._v("控制屏幕 横屏 / 竖屏 展示")]),e._v(" "),a("p",[e._v("定义启动画面")]),e._v(" "),a("p",[e._v("可以设置你的应用启动是从主屏幕启动还是从 URL 启动")]),e._v(" "),a("p",[e._v("可以设置你添加屏幕上的应用程序图标、名字、图标大小")]),e._v(" "),a("h4",{attrs:{id:"push-notification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#push-notification"}},[e._v("#")]),e._v(" Push Notification")]),e._v(" "),a("p",[e._v("Push 和 Notification 是两个不同的功能，涉及到两个 API 。")]),e._v(" "),a("p",[e._v("Notification 是浏览器发出的通知消息。")]),e._v(" "),a("p",[e._v("Push 和 Notification 的关系，Push：服务器端将更新的信息传递给 SW ，Notification： SW 将更新的信息推送给用户。")]),e._v(" "),a("h3",{attrs:{id:"pwa示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pwa示例"}},[e._v("#")]),e._v(" PWA示例")]),e._v(" "),a("p",[a("strong",[e._v("准备")])]),e._v(" "),a("p",[e._v("我们先创建一个关于 PWA 的项目文件夹，")]),e._v(" "),a("p",[e._v("进入文件夹下我们准备一张 120x120的图片一张，作为我们的应用程序图标。")]),e._v(" "),a("p",[e._v("创建一个 index.html 文件")]),e._v(" "),a("p",[e._v("创建一个 main.css 文件")]),e._v(" "),a("p",[e._v("创建一个 manifest.json 文件")]),e._v(" "),a("p",[e._v("创建一个 sw.js 文件")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639481?w=340&h=143",alt:"img"}})]),e._v(" "),a("p",[a("strong",[e._v("index.html")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <title>Hello PWA</title>\n  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">\n  <link rel="stylesheet" href="main.css">\n  <link rel="manifest" href="manifest.json">\n</head>\n<body>\n  <h3>Hello PWA</h3>\n</body>\n<script>\n  // 检测浏览器是否支持SW\n  if(navigator.serviceWorker != null){\n    navigator.serviceWorker.register(\'sw.js\')\n    .then(function(registartion){\n      console.log(\'支持sw:\',registartion.scope)\n    })\n  }\n<\/script>\n</html>\n')])])]),a("p",[a("strong",[e._v("main.css")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("h3{\n  color: #f00;\n}\n")])])]),a("p",[a("strong",[e._v("manifest.json")])]),e._v(" "),a("p",[e._v('short_name: “ " 用户主屏幕上的应用名字')]),e._v(" "),a("p",[e._v('display : “standalone" 设置启动样式，让您的网络应用隐藏浏览器的 URL 地址栏')]),e._v(" "),a("p",[e._v("start_url : “/“ 设置启动网址，如果不提供的话，默认是使用当前页面")]),e._v(" "),a("p",[e._v("theme_color : “ “ 用来告知浏览器用什么颜色来为地址栏等 UI 元素着色")]),e._v(" "),a("p",[e._v("background_color: “ ” 设置启动页面的背景颜色")]),e._v(" "),a("p",[e._v("icons：”” 就是添加到主屏幕之后的图标")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  "name": "一个PWA示例",\n  "short_name": "PWA示例",\n  "start_url": "/index.html",\n  "display": "standalone",\n  "background_color": "#fff",\n  "theme_color": "#3eaf7c",\n  "icons": [\n    {\n      "src": "/youhun.jpg",\n      "sizes": "120x120",\n      "type": "image/png"\n    }\n  ],\n}\n')])])]),a("p",[a("strong",[e._v("sw.js")])]),e._v(" "),a("p",[e._v("看网上很多人都安装的hs和ngrok去调试，在这里为了照顾新手我是直接引用的sw")]),e._v(" "),a("p",[e._v("处理静态缓存，首先定义需要缓存的路径，以及需要缓存的静态文件的列表。")]),e._v(" "),a("p",[e._v("借助 SW 注册完成安装 SW 时，抓取资源写入缓存中。使用了一个方法那就是 self.skipWaiting( ) ，为了在页面更新的过程当中，新的 SW 脚本能够立刻激活和生效。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("importScripts(\"https://storage.googleapis.com/workbox-cdn/releases/3.1.0/workbox-sw.js\");\nvar cacheStorageKey = 'minimal-pwa-1'\nvar cacheList=[\n  '/',\n  'index.html',\n  'main.css',\n  'youhun.jpg'\n]\nself.addEventListener('install',e =>{\n  e.waitUntil(\n    caches.open(cacheStorageKey)\n    .then(cache => cache.addAll(cacheList))\n    .then(() => self.skipWaiting())\n  )\n})\n")])])]),a("p",[e._v("处理动态缓存，我们监听 fetch 事件，在 caches 中去 match 事件的 request ，如果 response 不为空的话就返回 response ，最后返回 fetch 请求，在 fetch 事件中我们可以手动生成 response 返回给页面。")]),e._v(" "),a("p",[e._v("更新静态资源，缓存的资源会跟随着版本的更新会过期的，所以会根据缓存的字符串名称清除旧缓存。在新安装的 SW 中通过调用 self.clients.claim( ) 取得页面的控制权，这样之后打开页面都会使用版本更新的缓存。旧的 SW 脚本不在控制着页面之后会被停止，也就是会进入 Redundant 期。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("self.addEventListener('fetch',function(e){\n  e.respondWith(\n    caches.match(e.request).then(function(response){\n      if(response != null){\n        return response\n      }\n      return fetch(e.request.url)\n    })\n  )\n})\nself.addEventListener('activate',function(e){\n  e.waitUntil(\n    //获取所有cache名称\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        // 获取所有不同于当前版本名称cache下的内容\n        cacheNames.filter(cacheNames => {\n          return cacheNames !== cacheStorageKey\n        }).map(cacheNames => {\n          return caches.delete(cacheNames)\n        })\n      )\n    }).then(() => {\n      return self.clients.claim()\n    })\n  )\n})\n")])])]),a("p",[a("strong",[e._v("部署")])]),e._v(" "),a("p",[e._v("我们可以把当前pwa目录的所有内容都扔进服务器中，或者coding Pages和gitHub Pages也是可以的，当然，记得开启https。在上变介绍过SW的权利比较大，为了安全性，我们使用https协议来访问。")]),e._v(" "),a("p",[e._v("试着访问一下，我们这里用的coding Pages并且绑定了自己的域名")]),e._v(" "),a("p",[e._v("打开 chrom 的调试工具，打开 application ，点击 service workers 之后我们会发现 sw.js 脚本已经存到了 SW 中 。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639482?w=1617&h=863",alt:"img"}})]),e._v(" "),a("p",[e._v("我们打开 Network 刷新页面一下，看看，我们的页面资源来自 SW 而不是其他的地方，在 Console 中也打印出了我们在 index.html 中判断的语句，浏览器支持就会打印出这一句话。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639483?w=1032&h=368",alt:"img"}})]),e._v(" "),a("p",[e._v("接下来我们断网操作，在 Application 中给 Offline 打上对勾就行啦。然后刷新页面，我们仍然能看到之前的页面，原因就是我们在上图看到，他的资源是从 SW 上获得到的。当我们第一次打开这个页面的时候，Resopnse 对象被存到了 Cache Storage （ 定义在 SW 规范中 ，相关资料请同学们自行查询啦 ）中，我们看下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639484?w=827&h=461",alt:"img"}})]),e._v(" "),a("p",[e._v("通过存放到 Cache Storage 中，我们下次访问的时候如果是弱网或者断网的情况下，就可以不走网络请求，而直接就能将本地缓存的内容展示给用户，优化用户的弱网及断网体验。")]),e._v(" "),a("p",[e._v("这个时候肯定会有同学在想，如果内容更新了，那么页面展示的内容是新内容呢还是旧内容呢？下面我们操作一下，打开 index.html 文件，我们在 body 中添加一个 p 标签 ，然后回到页面刷新。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639485?w=713&h=258",alt:"img"}})]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639486?w=1731&h=715",alt:"img"}})]),e._v(" "),a("p",[e._v("我们看到，页面上的内容并没有显示出我刚刚添加的那个 p 标签。这说明了，我们拿到的数据还是从 Cache Storage 中获取到的，Cache Storage中的内容并没有更新，强制刷新也不行哦，那么我们怎么才能让我刚刚添加的那个 p 标签显示出来呢。")]),e._v(" "),a("p",[e._v("我们打开 sw.js 脚本文件，我们修改一下 cacheStorageKey。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639487?w=765&h=330",alt:"img"}})]),e._v(" "),a("p",[e._v("修改后，我们再次打开该网址，强制刷新下或者关掉浏览器重新打开。")]),e._v(" "),a("p",[e._v("页面中出现了刚刚添加的P标签，我们再看一下 Cache Storage 中的缓存名字，已经被修改。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000014639488?w=1473&h=548",alt:"img"}})]),e._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("如果是使用coding或者gitHub提供的pages服务，则需要注意最好绑定下独立域名。如果不绑定则注意下文件请求路径即可。")]),e._v(" "),a("p",[e._v("研究PWA门槛不低，部署的服务器要求HTTPS，ServiceWorker涉及API众多，需要单独学习，另外npm中也已经有这个包了"),a("a",{attrs:{href:"https://www.npmjs.com/package/web-pwa",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.npmjs.com/package..."),a("OutboundLink")],1),e._v(" ，玩玩可以，真正部署到项目生产环境可能坑很多，但有坑填坑，不折腾还叫前端么。")]),e._v(" "),a("p",[e._v("本作品系 原创， "),a("a",{attrs:{href:"https://creativecommons.org/licenses/by-nc-nd/4.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("采用《署名-非商业性使用-禁止演绎 4.0 国际》许可协议"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"原文链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原文链接"}},[e._v("#")]),e._v(" 原文链接")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000014639473",target:"_blank",rel:"noopener noreferrer"}},[e._v("PWA介绍及快速上手搭建一个PWA应用"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);